# 260203 검색 기능 만들기 – 작업·공부 정리

오늘은 처음부터 완성된 코드가 아니라, **기능을 만드는 순서대로 생각하고 작성한 뒤 리팩토링해 보기**를 목표로 했다.

---

## 1. 어떤 순서로 생각했는지

### 1단계: 페이지 로드 시 목록 보여주기

- **데이터가 있어야 화면에 뭘 보여줄지 정할 수 있다** → API는 `api.js`의 `fetchTodosData` 사용.
- **한 개 아이템의 모양**을 먼저 정함 → `uiListData(실제api타이틀)`로 li + p 생성.
- **데이터 가져와서 화면에 보여주자** → `createlistData()`에서 fetch 후, 그 데이터를 어디에 어떻게 그릴지 생각함.
- 이때 “데이터를 리스트로 그리는 로직”이 반복되니까 **`renderData(생성된li가들어갈곳, 실제데이터)`**로 분리함. (리팩토링에서 나온 함수)

### 2단계: 검색 시나리오

- **input에 뭔가 치면** 기존 리스트는 비우기 → `addEventListener('input', ...)`에서 `innerHTML = ''`.
- **검색 버튼 클릭** 또는 **Enter** → 검색 실행 → `searchFn`.
- 검색 = **원본 데이터**를 **검색어**로 걸러서 → **검색된 데이터**만 `renderData`로 다시 그리기.
- 필터는 “검색어가 title에 포함된 것만 남기기” → `filterTodosByQuery(원본데이터, 검색어)`, `filter`로 구현.

---

## 2. 공부하면서 정리한 개념

### 함수의 ( ) 안 – 파라미터

- `()` 안에는 **이 함수가 일할 때 밖에서 받아야 할 값**을 적는다.
- `renderData(생성된li가들어갈곳, 실제데이터)` → “어디에”, “무슨 데이터를” 그릴지 호출하는 쪽에서 넘겨준다. 함수는 그때그때 받은 값으로만 동작한다.

### addEventListener와 `e` (이벤트 객체)

- **`e`가 필요할 때**: 이벤트에 대해 **궁금한 게 있을 때** (어떤 키인지, 기본 동작 막기, 클릭한 요소 등).
- **`e`가 없어도 될 때**: “클릭됐으면 이 함수만 실행”처럼 이벤트 내용을 안 쓸 때.
- `keypress`에서는 **Enter만** 처리하려고 `e.key === 'Enter'`를 쓰고, **기본 동작(줄바꿈 등) 막기**를 위해 `e.preventDefault()`를 썼기 때문에 `(e)`를 받았다.

### 함수 호출 vs 참조

- **`searchFn`** → 함수를 “가리키기”만 함. 실행되지 않음.
- **`searchFn()`** → 함수를 “실행”함.
- `addEventListener('click', searchFn)`은 콜백으로 함수 참조를 넘기는 거라, 클릭 시 브라우저가 대신 호출해 준다.
- `keypress` 안에서는 직접 “Enter일 때 검색 실행”을 해야 하니까 **`searchFn()`**으로 호출해야 했다. 여기서 `searchFn`만 쓰여 있어서 검색 결과가 안 나오는 버그가 있었다.

### 같은 값, 다른 이름

- `검색어공백제거 = SearchText.value.trim()` (input 이벤트), `검색할키워드 = SearchText.value.trim()` (searchFn) → **값은 같다.**
- 쓰는 맥락이 다르니까 이름을 다르게 둔 것: 하나는 “입력값 있는지 체크”, 하나는 “검색에 쓸 키워드”.

---

## 3. 겪었던 오류와 원인

| 상황 | 원인 | 해결 |
|------|------|------|
| `list.innerHTML = ''` 오류 | `renderData(list, data)`를 **인자 없이** `renderData()`로만 호출 → `list`가 `undefined` | 호출할 때 `list`(DOM), `data`(배열) 넘기기 |
| 검색한 데이터가 리스트로 안 나옴 | Enter 키 핸들러에서 `searchFn`만 쓰고 **`searchFn()` 호출을 안 함** | `searchFn()`으로 바꿔서 실행되게 함 |
| `list` 오류 | `createlistData` 안에서 `list`를 쓰는데, **`list` 변수를 선언하지 않음** | `const 생성된li가들어갈곳 = document.querySelector('.search_list')` 같은 식으로 DOM 요소를 변수에 담아서 사용 |

---

## 4. 한글 변수로 의미 잡기

- 이해를 위해 변수명을 한글로 써 봤다.
- **역할이 드러나게**: `생성된li가들어갈곳`(ul), `실제데이터`(API 배열), `검색된데이터`(필터 결과), `원본데이터`(필터 전).
- **요소 vs 상황**: “데이터가 없을 때 보여줄 **요소**”라서 `데이터가없을경우의li`, “데이터가 있을 때의 **요소**”라서 `데이터가있을경우의li`처럼, 담는 값(li 요소)이 이름에 드러나도록 했다.
- 나중에 실제 프로젝트에서는 영문 변수로 바꿔도, **의미를 먼저 한글로 생각해 본 게 도움이 됐다.**

---

## 5. 오늘 흐름 요약

1. **데이터 가져오기** → **한 개 아이템 UI** → **전체 리스트 그리기** 순서로 생각했다.
2. **리스트 그리기**가 “초기 로드”와 “검색 결과” 둘 다에서 쓰이니까 `renderData`로 빼서 재사용했다.
3. **검색**은 “원본 데이터 + 검색어 → 필터 → `renderData`” 한 줄로 정리했다.
4. **이벤트**: input으로 리스트 비우기, click으로 검색, keypress에서 Enter일 때만 검색 실행 + `e.preventDefault()`.
5. **버그**는 “인자 안 넘김”, “함수 참조만 하고 호출 안 함”, “DOM 변수 미선언”에서 나왔고, 하나씩 고치면서 **파라미터·이벤트·함수 호출** 개념을 다시 짚었다.

이 순서와 생각을 260203.js에 주석과 한글 변수로 남겨 두었다.


---

## 질문과 답변

### 1. 언제 async 함수를 만들고 언제 그냥 함수를 만들어야 할지 기준이 있을까?

**기준: “기다려야 하는 일”이 있으면 async, 없으면 일반 함수.**

| 사용 | 언제 |
|------|------|
| **async 함수** | `await`로 **기다리는 일**이 있을 때. 예: `fetch`, API 호출, 파일 읽기, 타이머 등 시간이 걸리는 작업 뒤에 이어서 처리할 때. |
| **일반 함수** | 기다릴 게 없을 때. DOM 조작, 계산, 필터링, 이벤트에서 바로 처리하는 짧은 로직 등. |

- `createlistData`, `searchFn`은 **API 결과를 기다린 뒤** 그 결과로 렌더링하니까 async.
- `renderData`, `filterTodosByQuery`, `uiListData`는 **기다릴 일이 없어서** 일반 함수.

---

### 2. 왜 addEventListener는 함수로 만들지 않고 바로 실행되게 적는 거야?

**둘 다 “함수”를 넘기는 것이다. 이름 있는 함수를 넘길 수도 있고, 그 자리에서 만든 함수(화살표 함수)를 넘길 수도 있다.**

| 방식 | 예시 | 쓰는 경우 |
|------|------|-----------|
| **이름 있는 함수** | `addEventListener('click', searchFn)` | 그 함수를 여러 곳에서 쓰거나, 로직이 길 때. |
| **그 자리에서 만든 함수** | `addEventListener('keypress', (e) => { ... })` | 그 이벤트에서만 쓰고, `e`를 써야 하거나 로직이 짧을 때. |

- `(e) => { ... }` 도 **함수**다. 이름만 없을 뿐(익명 함수).
- “함수로 만들지 않고”가 아니라, **이벤트가 발생할 때 실행될 콜백**을 넘기는 것이다. 이름 있는 함수를 넘기면 나중에 그 이름으로 호출되고, 화살표 함수를 넘기면 나중에 그 함수가 호출된다.
- 정리: **재사용·가독성**이 중요하면 이름 있는 함수, **한 이벤트 전용 + e 사용**이면 그 자리에서 `(e) => { ... }` 로 적는 경우가 많다.